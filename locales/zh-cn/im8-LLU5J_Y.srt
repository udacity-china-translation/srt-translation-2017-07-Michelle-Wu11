1
00:00:00,252 --> 00:00:02,825
我们谈过了不同的分流方式

2
00:00:02,825 --> 00:00:04,552
那你如何在它们之间做出选择呢？

3
00:00:04,552 --> 00:00:06,873
主要考虑有三点

4
00:00:06,873 --> 00:00:09,023
第一是用户一致性

5
00:00:09,023 --> 00:00:13,690
如果使用用户 ID 那么用户获得的体验是连贯的

6
00:00:13,690 --> 00:00:16,462
只要是登录状态 就算更换设备也不会影响体验

7
00:00:16,462 --> 00:00:19,347
那么对于某些更改 比如

8
00:00:19,347 --> 00:00:22,299
测试课程展示效果

9
00:00:22,299 --> 00:00:25,855
那么用户在各个设备的体验都是一致的

10
00:00:25,855 --> 00:00:29,543
另一方面 如果你测试的更改项会影响登录前后的效果

11
00:00:29,543 --> 00:00:32,530
那么用户 ID 用处就不大了

12
00:00:32,530 --> 00:00:35,573
比如 如果你要变更页面布局

13
00:00:35,573 --> 00:00:37,195
或登录按钮的位置

14
00:00:37,195 --> 00:00:41,473
此情况下 你反而会用 cookie 使登录前后体验一致

15
00:00:41,473 --> 00:00:45,208
但不能保证设备间的一致

16
00:00:45,208 --> 00:00:46,067
好的

17
00:00:46,067 --> 00:00:49,442
所以 只要情况满足 你总会使用用户 ID 或 cookie

18
00:00:49,442 --> 00:00:51,650
以获得某种一致性 对吗？

19
00:00:51,650 --> 00:00:55,795
对于用户可见更改 你一定会使用 cookie 或 用户 ID

20
00:00:55,795 --> 00:00:57,194
现在问题是

21
00:00:57,194 --> 00:01:01,698
可能许多更改都是用户看不见的

22
00:01:01,698 --> 00:01:06,577
从延迟变化到后台架构的变化

23
00:01:06,577 --> 00:01:08,703
或说是排序变化

24
00:01:08,703 --> 00:01:12,648
很多时候 用户无法辨别排序功能的改变

25
00:01:12,648 --> 00:01:17,455
用户可见性是考虑因素之一

26
00:01:17,455 --> 00:01:19,865
它决定使用用户 ID 还是 cookie

27
00:01:19,865 --> 00:01:21,786
另一个要考虑的是你的测量内容

28
00:01:21,786 --> 00:01:25,794
比如 如果你想测量学习效果

29
00:01:25,794 --> 00:01:27,425
用户是否适应更改

30
00:01:27,425 --> 00:01:28,637
在这些案例中

31
00:01:28,637 --> 00:01:33,498
你还是需要 cookie 或用户 ID 这种状态稳定的分组单元

32
00:01:33,498 --> 00:01:37,201
比如 如果你在设置网络延迟 网站速度减缓

33
00:01:37,201 --> 00:01:40,753
你要确认用户使用量是否减少

34
00:01:40,753 --> 00:01:43,282
这种情况下 你需要用 cookie 或用户 ID

35
00:01:43,282 --> 00:01:45,825
去检查一段时间内的情况

36
00:01:45,825 --> 00:01:48,323
即便用户注意不到变化

37
00:01:48,323 --> 00:01:52,255
但还得看你要测量的是什么 你可以选择用户 ID 或 cookie

38
00:01:52,255 --> 00:01:53,358
好的 很有道理

39
00:01:53,358 --> 00:01:56,728
那么相比之下 基于 IP 地址的分组怎么样？

40
00:01:56,728 --> 00:02:00,433
一般上 我觉得基于 IP 地址的分组用处不大

41
00:02:00,433 --> 00:02:04,003
不像用户 ID 或 cookie 它不具备一致性

42
00:02:04,003 --> 00:02:07,632
因为用户的 IP 地址会随机变化

43
00:02:07,632 --> 00:02:09,187
这取决于你的网络提供商

44
00:02:09,187 --> 00:02:13,125
IP 地址也无法提供如基于事件分组的随机结果

45
00:02:13,125 --> 00:02:14,133
虽然这么说

46
00:02:14,133 --> 00:02:19,498
可很多变更或许只能用基于 IP 的分组

47
00:02:19,498 --> 00:02:23,435
比如 你要测试架构的变化

48
00:02:23,435 --> 00:02:26,771
你会在两个主机服务商之间作比较

49
00:02:26,771 --> 00:02:28,425
从而了解网络延迟的影响

50
00:02:28,425 --> 00:02:33,057
这种情况下 基于 IP 的分组会是唯一选择

51
00:02:33,057 --> 00:02:35,600
当你使用基于 IP 的分组

52
00:02:35,600 --> 00:02:38,770
一个关键的难点就在于分析

53
00:02:38,770 --> 00:02:41,741
因为通过基于 IP 地址的分组 你无法

54
00:02:41,741 --> 00:02:45,670
在实验组和对照组之间获得纯粹的对比结果

55
00:02:45,670 --> 00:02:49,325
一个例子就是 调制解调器拨号

56
00:02:49,325 --> 00:02:52,047
我知道它不太流行了 但还在使用

57
00:02:52,047 --> 00:02:56,506
一些供应商会集合这些调制解调器拨号用户

58
00:02:56,506 --> 00:02:58,853
到一个 IP 地址下

59
00:02:58,853 --> 00:03:03,389
那么问题是我怎么才能找到对照组内

60
00:03:03,389 --> 00:03:04,325
可比较的用户总体？

61
00:03:04,325 --> 00:03:06,733
所以 基于 IP 分组后要做的是

62
00:03:06,733 --> 00:03:10,313
通过很多后续分析试着找到

63
00:03:10,313 --> 00:03:13,860
实验组和对照组的对比
