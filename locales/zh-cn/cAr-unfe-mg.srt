1
00:00:00,025 --> 00:00:03,440
对于任何问题 我们首先需要回答的是 输入是什么？

2
00:00:03,440 --> 00:00:07,334
对于这个问题 他们相当清楚地声明 给出你的生日和

3
00:00:07,334 --> 00:00:10,502
当前日期 好 这是该问题的输入 不过我们真正想要

4
00:00:10,502 --> 00:00:13,685
计算的输入是什么？真的只是单纯计算“我的生日”和

5
00:00:13,685 --> 00:00:17,305
“今天的日期”吗？如果这就是我们想要的话 一次计算就可以

6
00:00:17,305 --> 00:00:20,508
解出 我们不必去写一个过程 所以我想

7
00:00:20,508 --> 00:00:24,729
这里指的是更普遍的含义 因此 输入实际上是两个

8
00:00:24,729 --> 00:00:27,803
日期 这为我们提供了输入的类型 提供了所有可能的

9
00:00:27,803 --> 00:00:31,180
输入集合 我们需要一些更谨慎的思考去确认输入是否有效

10
00:00:31,180 --> 00:00:34,283
那么 问题陈述这里给我们一个很好的线索 它说

11
00:00:34,283 --> 00:00:38,561
假设出生日期和当前日期都是正确的日期 并且不存在时间旅行

12
00:00:38,561 --> 00:00:41,988
如果我们谈论的是出生日期和当前日期 这很可能是个有效的假设

13
00:00:41,988 --> 00:00:46,499
如果我们比较任何两个日期 这意味着第二个日期应该

14
00:00:46,499 --> 00:00:51,152
在第一个之后 这样的假设使程序员的生活更轻松

15
00:00:51,152 --> 00:00:55,660
意味着可以更容易地写我们的代码 因为它只需计算

16
00:00:55,660 --> 00:00:59,768
更少的输入集合 我喜欢 Mattias 这里没有时间旅行的陈述

17
00:00:59,768 --> 00:01:04,058
不过对于程序规范 我们可能想要更精确一点

18
00:01:04,058 --> 00:01:08,200
只需简单陈述 第二个日期必须不在第一个日期之前 如果我们是

19
00:01:08,200 --> 00:01:11,244
有着良好意识的程序员 我们应当检查这是否是真的

20
00:01:11,244 --> 00:01:16,458
这是一条假设 它要求我们代码的使用者满足它 因为我们已经说了

21
00:01:16,458 --> 00:01:20,610
这是一个要求 要使用我们的解法 你必须确保第二个日期

22
00:01:20,610 --> 00:01:24,020
不在第一个日期之前 但是我们如果想更巧妙的话 我们应当以

23
00:01:24,020 --> 00:01:27,485
更严谨的方式编程 因为有时人们可能会犯错

24
00:01:27,485 --> 00:01:30,944
当然也包括我们自己 所以我们实际上将会在代码中检查

25
00:01:30,944 --> 00:01:34,835
另一个我们想要的假设可能是日期的范围

26
00:01:34,835 --> 00:01:39,105
历法是很复杂的 它们随着历史演变

27
00:01:39,105 --> 00:01:44,110
我们将要求日期是有效的公历日期

28
00:01:44,110 --> 00:01:48,142
公历从 1582 年 10 月开始 我们的代码对于在这个范围之外的日期也许会

29
00:01:48,142 --> 00:01:51,726
有效 但很可能不会得到正确的答案

30
00:01:51,726 --> 00:01:53,553
因为当历法改变时 日期的含义也改变了
