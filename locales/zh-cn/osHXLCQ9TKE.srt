1
00:00:00,008 --> 00:00:04,183
我将会讨论 最好的答案是第四个选项

2
00:00:04,183 --> 00:00:07,989
现在的代码已经相当复杂 大量的语句 但是并没有处理所有情况

3
00:00:07,989 --> 00:00:12,100
所以让我们考虑以下那些它没有处理的情况

4
00:00:12,100 --> 00:00:16,450
没有处理的情况是初始日期在同一个月份

5
00:00:16,450 --> 00:00:20,146
它无法处理这种情况 因为我们会把 month1 的值加到 days 变量

6
00:00:20,146 --> 00:00:23,450
如果 day2 也在 month1 的话 我们把它们加起来会得到错误的答案

7
00:00:23,450 --> 00:00:27,440
我们可以处理这种情况 我们可以减去 days 变量中多余的那部分

8
00:00:27,440 --> 00:00:30,576
或者我们可以做一些修正在 while 循环里

9
00:00:30,576 --> 00:00:33,526
针对月份相同的情况 但这是令人痛苦的

10
00:00:33,526 --> 00:00:36,868
我们需要一个新的特殊情况 添加一个新的特殊情况还好

11
00:00:36,868 --> 00:00:40,389
但是这里还有其他的特殊情况 它没有处理 month2 在 month1 之前的情况

12
00:00:40,389 --> 00:00:43,914
这个可以在年份不同时发生 这仍然是第二日期在第一日期之后的情况

13
00:00:43,914 --> 00:00:47,034
即使第二个月在第一个月之前

14
00:00:47,034 --> 00:00:50,054
它也不会正确的处理这种情况

15
00:00:50,054 --> 00:00:54,014
另一件不能正确处理的事情是计算闰年的天数

16
00:00:54,014 --> 00:00:57,782
我们在这个循环里增加 days 变量时 

17
00:00:57,782 --> 00:01:02,021
我们必须小心根据我们所处的月份确定是否包括2月

18
00:01:02,021 --> 00:01:05,732
我们是否应该注意 year1 或者 year2 的天数

19
00:01:05,732 --> 00:01:08,498
有太多的情况我们没有处理 我们可以修复伪码使得它可以处理

20
00:01:08,498 --> 00:01:12,014
如果你选了第二项 我鼓励你去试试

21
00:01:12,014 --> 00:01:15,406
并使得这段伪码正确工作

22
00:01:15,406 --> 00:01:18,533
你应当可以做到那样 但是我们作为程序员的目标是首先尝试并找到一个简单的解法

23
00:01:18,533 --> 00:01:21,942
这段伪码很难保持始终正确

24
00:01:21,942 --> 00:01:24,945
一旦你开始处理大量特殊例子 我已经见到论坛里很多尝试这样

25
00:01:24,945 --> 00:01:27,940
坐的人的很多讨论

26
00:01:27,940 --> 00:01:30,850
使得代码一直正确是非常难的 并且这使得代码更复杂

27
00:01:30,850 --> 00:01:33,586
所以让我们思考更简单的方式

28
00:01:33,586 --> 00:01:36,823
通常人们解决问题的方式不是最简单的 因为人的本性是懒惰的

29
00:01:36,823 --> 00:01:40,520
我们想找到捷径 而不是以真实简单机械的方式做事情

30
00:01:40,520 --> 00:01:43,990
另一方面 计算机不是懒惰的 真实简单机械的方式对计算机来说很棒

31
00:01:43,990 --> 00:01:47,234
这使得程序更容易编写 

32
00:01:47,234 --> 00:01:47,843
使其更可能是正确的
